var documenterSearchIndex = {"docs":
[{"location":"tutorials/first_model/#A-first-model","page":"A first model","title":"A first model","text":"","category":"section"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"In this tutorial, we will fit our very first Structural Equation Model with our package.  The example we are using is from the lavaan tutorial, so it may be familiar. It looks like this:","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"– include image here –","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"We assume the StructuralEquationModels package is already installed. To use it in the current session, we run","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"using StructuralEquationModels","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"We then first define the graph of our model in a syntax which is similar to the R-package lavaan:","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"observed_vars = [:x1, :x2, :x3, :y1, :y2, :y3, :y4, :y5, :y6, :y7, :y8]\nlatent_vars = [:ind60, :dem60, :dem65]\n\ngraph = @StenoGraph begin\n\n    # loadings\n    ind60 → fixed(1)*x1 + x2 + x3\n    dem60 → fixed(1)*y1 + y2 + y3 + y4\n    dem65 → fixed(1)*y5 + y6 + y7 + y8\n\n    # latent regressions\n    ind60 → dem60\n    dem60 → dem65\n    ind60 → dem65\n\n    # variances\n    _(observed_vars) ↔ _(observed_vars)\n    _(latent_vars) ↔ _(latent_vars)\n\n    # covariances\n    y1 ↔ y5\n    y2 ↔ y4 + y6\n    y3 ↔ y7\n    y8 ↔ y4 + y6\n\nend","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"We then use this graph to define a ParameterTable object","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"partable = ParameterTable(\n    latent_vars = latent_vars, \n    observed_vars = observed_vars, \n    graph = graph)","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"load the example data","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"data = example_data(\"political_democracy\")","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"and specify our model as","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"model = Sem(\n    specification = partable,\n    data = data\n)","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"We can now fit the model via","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"model_fit = sem_fit(model)","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"and compute fit measures as","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"fit_measures(model_fit)\n\n# output\n\nDict{Symbol, Union{Missing, Float64}} with 8 entries:\n  :minus2ll => 3106.66\n  :AIC      => 3168.66\n  :BIC      => 3240.5\n  :df       => 35.0\n  :χ²       => 37.6169\n  :p_value  => 0.350263\n  :RMSEA    => 0.0315739\n  :n_par    => 31.0","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"We can also get a bit more information about the fitted model via the sem_summary() function:","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"sem_summary(model_fit)\n\n# output\n\nFitted Structural Equation Model\n\n--------------------------------- Properties ---------------------------------\n\nOptimization algorithm:      L-BFGS\nConvergence:                 true\nNo. iterations/evaluations:  136\n\nNumber of parameters:        31\nNumber of observations:      75.0\n\n----------------------------------- Model -----------------------------------\n\nStructural Equation Model\n- Loss Functions\n   SemML\n- Fields\n   observed:  SemObsCommon\n   imply:     RAM\n   diff:      SemDiffOptim","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"To investigate the parameter estimates, we can update our partable object to contain the new estimates:","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"update_estimate!(partable, model_fit)","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"and investigate the solution with","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"sem_summary(partable)\n\n# output\n\n--------------------------------- Variables ---------------------------------\n\nLatent variables:    ind60 dem60 dem65\nObserved variables:  x1 x2 x3 y1 y2 y3 y4 y5 y6 y7 y8\n\n---------------------------- Parameter Estimates -----------------------------\n\nLoadings:\n\nind60\n\n  to   estimate   identifier   value_fixed   start   parameter_type   from    free\n\n  x1   0.0        const        1.0           0.0     →                ind60   0.0\n  x2   2.18       θ_1          0.0           0.0     →                ind60   1.0\n  x3   1.82       θ_2          0.0           0.0     →                ind60   1.0\n\ndem60\n\n  to   estimate   identifier   value_fixed   start   parameter_type   from    free\n\n  y1   0.0        const        1.0           0.0     →                dem60   0.0\n  y2   1.26       θ_3          0.0           0.0     →                dem60   1.0\n  y3   1.06       θ_4          0.0           0.0     →                dem60   1.0\n  y4   1.26       θ_5          0.0           0.0     →                dem60   1.0\n\ndem65\n\n  to   estimate   identifier   value_fixed   start   parameter_type   from    free\n\n  y5   0.0        const        1.0           0.0     →                dem65   0.0\n  y6   1.19       θ_6          0.0           0.0     →                dem65   1.0\n  y7   1.28       θ_7          0.0           0.0     →                dem65   1.0\n  y8   1.27       θ_8          0.0           0.0     →                dem65   1.0\n\nDirected Effects:\n\n  from        to      estimate   identifier   value_fixed   start   free\n\n  ind60   →   dem60   1.48       θ_9          0.0           0.0     1.0\n  dem60   →   dem65   0.84       θ_10         0.0           0.0     1.0\n  ind60   →   dem65   0.57       θ_11         0.0           0.0     1.0\n\nVariances:\n\n  from        to      estimate   identifier   value_fixed   start   free\n\n  x1      ↔   x1      0.08       θ_12         0.0           0.0     1.0\n  x2      ↔   x2      0.12       θ_13         0.0           0.0     1.0\n  x3      ↔   x3      0.47       θ_14         0.0           0.0     1.0\n  y1      ↔   y1      1.92       θ_15         0.0           0.0     1.0\n  y2      ↔   y2      7.47       θ_16         0.0           0.0     1.0\n  y3      ↔   y3      5.14       θ_17         0.0           0.0     1.0\n  y4      ↔   y4      3.19       θ_18         0.0           0.0     1.0\n  y5      ↔   y5      2.38       θ_19         0.0           0.0     1.0\n  y6      ↔   y6      5.02       θ_20         0.0           0.0     1.0\n  y7      ↔   y7      3.48       θ_21         0.0           0.0     1.0\n  y8      ↔   y8      3.3        θ_22         0.0           0.0     1.0\n  ind60   ↔   ind60   0.45       θ_23         0.0           0.0     1.0\n  dem60   ↔   dem60   4.01       θ_24         0.0           0.0     1.0\n  dem65   ↔   dem65   0.17       θ_25         0.0           0.0     1.0\n\nCovariances:\n\n  from       to   estimate   identifier   value_fixed   start   free\n\n  y1     ↔   y5   0.63       θ_26         0.0           0.0     1.0\n  y2     ↔   y4   1.33       θ_27         0.0           0.0     1.0\n  y2     ↔   y6   2.18       θ_28         0.0           0.0     1.0\n  y3     ↔   y7   0.81       θ_29         0.0           0.0     1.0\n  y8     ↔   y4   0.35       θ_30         0.0           0.0     1.0\n  y8     ↔   y6   1.37       θ_31         0.0           0.0     1.0","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"Congratulations, you fitted and inspected your very first model! To learn more about the different parts,  you may visit the sections on Model specification, Model construction, model fitting (XXX) and model inspection (XXX).","category":"page"},{"location":"tutorials/first_model/","page":"A first model","title":"A first model","text":"If you want to learn how to extend the package (e.g., add a new loss function), you may visit the developer documentation (XXX).","category":"page"},{"location":"tutorials/specification/parameter_table/#ParameterTable-interface","page":"ParameterTable interface","title":"ParameterTable interface","text":"","category":"section"},{"location":"tutorials/specification/ram_matrices/#RAMMatrices-interface","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"","category":"section"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"Models can also be specified by an object of type RAMMatrices. The RAM (reticular action model) specification corresponds to three matrices; the A matrix containing all directed parameters, the S matrix containing all undirected parameters, and the F matrix filtering out latent variables from the model implied covariance.","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"The model implied covariance matrix for the observed variables of a SEM is then computed as","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"Sigma = F(I-A)^-1S(I-A)^-TF^T","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"For A first model, the corresponding specification looks like this:","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"\n\nS =[:θ1   0    0     0     0      0     0     0     0     0     0     0     0     0\n    0     :θ2  0     0     0      0     0     0     0     0     0     0     0     0\n    0     0     :θ3  0     0      0     0     0     0     0     0     0     0     0\n    0     0     0     :θ4  0      0     0     :θ15  0     0     0     0     0     0\n    0     0     0     0     :θ5   0     :θ16  0     :θ17  0     0     0     0     0\n    0     0     0     0     0     :θ6  0      0     0     :θ18  0     0     0     0\n    0     0     0     0     :θ16  0     :θ7   0     0     0     :θ19  0     0     0\n    0     0     0     :θ15 0      0     0     :θ8   0     0     0     0     0     0\n    0     0     0     0     :θ17  0     0     0     :θ9   0     :θ20  0     0     0\n    0     0     0     0     0     :θ18 0      0     0     :θ10  0     0     0     0\n    0     0     0     0     0     0     :θ19  0     :θ20  0     :θ11  0     0     0\n    0     0     0     0     0     0     0     0     0     0     0     :θ12  0     0\n    0     0     0     0     0     0     0     0     0     0     0     0     :θ13  0\n    0     0     0     0     0     0     0     0     0     0     0     0     0     :θ14]\n\nF =[1.0 0 0 0 0 0 0 0 0 0 0 0 0 0\n    0 1 0 0 0 0 0 0 0 0 0 0 0 0\n    0 0 1 0 0 0 0 0 0 0 0 0 0 0\n    0 0 0 1 0 0 0 0 0 0 0 0 0 0\n    0 0 0 0 1 0 0 0 0 0 0 0 0 0\n    0 0 0 0 0 1 0 0 0 0 0 0 0 0\n    0 0 0 0 0 0 1 0 0 0 0 0 0 0\n    0 0 0 0 0 0 0 1 0 0 0 0 0 0\n    0 0 0 0 0 0 0 0 1 0 0 0 0 0\n    0 0 0 0 0 0 0 0 0 1 0 0 0 0\n    0 0 0 0 0 0 0 0 0 0 1 0 0 0]\n\nA =[0  0  0  0  0  0  0  0  0  0  0     1.0   0     0\n    0  0  0  0  0  0  0  0  0  0  0     :θ21  0     0\n    0  0  0  0  0  0  0  0  0  0  0     :θ22  0     0\n    0  0  0  0  0  0  0  0  0  0  0     0     1.0   0\n    0  0  0  0  0  0  0  0  0  0  0     0     :θ23  0\n    0  0  0  0  0  0  0  0  0  0  0     0     :θ24  0\n    0  0  0  0  0  0  0  0  0  0  0     0     :θ25  0\n    0  0  0  0  0  0  0  0  0  0  0     0     0     1\n    0  0  0  0  0  0  0  0  0  0  0     0     0     :θ26\n    0  0  0  0  0  0  0  0  0  0  0     0     0     :θ27\n    0  0  0  0  0  0  0  0  0  0  0     0     0     :θ28\n    0  0  0  0  0  0  0  0  0  0  0     0     0     0\n    0  0  0  0  0  0  0  0  0  0  0     :θ29  0     0\n    0  0  0  0  0  0  0  0  0  0  0     :θ30  :θ31  0]\n\nθ = Symbol.(\"θ\".*string.(1:31))\n\nspec = RAMMatrices(;\n    A = A, \n    S = S, \n    F = F, \n    parameters = θ,\n    colnames = [:x1, :x2, :x3, :y1, :y2, :y3, :y4, :y5, :y6, :y7, :y8, :ind60, :dem60, :dem65]\n)\n\nmodel = Sem(\n    specification = spec,\n    ...\n)","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"Let's have a look at what to do step by step:","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"First, we specify the A, S and F-Matrices. For a free parameter, we write a Symbol like :θ1 (or any other symbol we like) to the corresponding place in the respective matrix, the constrain parameters to be equal we just use the same Symbol in the respective entries. To fix a parameter (as in the A-Matrix above), we just write down the number we want to fix it to. All other entries are 0.","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"Second, we specify a vector of symbols containing our parameters.","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"Third, we construct an object of type RAMMatrices, and pass our matrices and parameters, as well as the column names of our matrices to it. Those are quite important, as they will be used to rearrange your data to match it to your RAMMatrices specification.","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"Finally, we construct a model, passing our RAMMatrices as the specification = ... argument.","category":"page"},{"location":"tutorials/specification/ram_matrices/#Meanstructure","page":"RAMMatrices interface","title":"Meanstructure","text":"","category":"section"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"According to the RAM, model implied mean values of the observed variables are computed as","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"mu = F(I-A)^-1M","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"where M is a vector of mean parameters. To estimate the means of the observed variables in our example (and set the latent means to 0), we would specify the model just as before but add ","category":"page"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"...\n\nM = [:x32; :x33; :x34; :x35; :x36; :x37; :x38; :x39; :x40; :x41; :x42; 0; 0; 0]\n\nθ = Symbol.(\"θ\".*string.(1:42))\n\nspec = RAMMatrices(;\n    ...,\n    M = M)\n\n...\n","category":"page"},{"location":"tutorials/specification/ram_matrices/#Convert-from-and-to-ParameterTables","page":"RAMMatrices interface","title":"Convert from and to ParameterTables","text":"","category":"section"},{"location":"tutorials/specification/ram_matrices/","page":"RAMMatrices interface","title":"RAMMatrices interface","text":"To convert a RAMMatrices object (lets keep the namespecfrom above) to a ParameterTable, simply usepartable = ParameterTable(spec). To convert an object of typeParameterTableto RAMMatrices, you can useram_matrices = ()`","category":"page"},{"location":"tutorials/specification/specification/#Model-specification","page":"Model specification","title":"Model specification","text":"","category":"section"},{"location":"tutorials/specification/specification/","page":"Model specification","title":"Model specification","text":"We provide different interfaces for specifying a model: the Graph interface, the ParameterTable interface, and the RAMMatrices interface. These different specification objects can be (and are internally) converted to each other; but not every conversion is possible - see this picture:","category":"page"},{"location":"tutorials/specification/specification/","page":"Model specification","title":"Model specification","text":"imagine flowchart here -","category":"page"},{"location":"tutorials/specification/specification/","page":"Model specification","title":"Model specification","text":"In general (and especially if you come from lavaan), it is the easiest to follow the steps from the page A first model, that is specify a graph object, convert it to a prameter table, and use this parameter table to construct your models:","category":"page"},{"location":"tutorials/specification/specification/","page":"Model specification","title":"Model specification","text":"observed_vars = ...\nlatent_vars   = ...\n\ngraph = @StenoGraph begin\n    ...\nend\n\npartable = ParameterTable(\n    latent_vars = latent_vars, \n    observed_vars = observed_vars, \n    graph = graph)\n\nmodel = Sem(\n    specification = partable,\n    ...\n)","category":"page"},{"location":"tutorials/specification/specification/","page":"Model specification","title":"Model specification","text":"If you have an OpenMx background, and are familiar with their way of specifying structural equation models via RAM matrices, the RAMMatrices interface may be of interest for you.","category":"page"},{"location":"tutorials/multigroup/multigroup/#How-to-fit-a-multigroup-model","page":"How to fit a multigroup model","title":"How to fit a multigroup model","text":"","category":"section"},{"location":"tutorials/specification/graph_interface/#Graph-interface","page":"Graph interface","title":"Graph interface","text":"","category":"section"},{"location":"tutorials/specification/graph_interface/#Workflow","page":"Graph interface","title":"Workflow","text":"","category":"section"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"As discussed before, when using the graph interface, you can specify your model as a graph","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"graph = @StenoGraph begin\n    ...\nend","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"and convert it to a ParameterTable to construct your models:","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"observed_vars = ...\nlatent_vars   = ...\n\npartable = ParameterTable(\n    latent_vars = latent_vars, \n    observed_vars = observed_vars, \n    graph = graph)\n\nmodel = Sem(\n    specification = partable,\n    ...\n)","category":"page"},{"location":"tutorials/specification/graph_interface/#Parameters","page":"Graph interface","title":"Parameters","text":"","category":"section"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"In general, there are two different types of parameters: directed and indirected parameters. A directed parameter from the variable x to y can be specified as x → y (or equivalently as y ← x); an undirected parameter as x ↔ y. We allow multiple variables on both sides of an arrow, for example x → [y z] or [a b] → [c d]. The later specifies element wise edges; that is its the same as a → c; b → d. If you want edges corresponding to the cross-product, we have the double lined arrow [a b] ⇒ [c d], corresponding to a → c; a → d; b → c; b → d. The undirected arrows ↔ (element-wise) and ⇔ (crossproduct) behave the same way.","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"note: Unicode symbols in julia\nThe → symbol is a unicode symbol allowed in julia (among many others; see this list). You can enter it in the julia REPL or the vscode IDE by typing \\to followed by hitting tab. Similarly, ← = \\leftarrow,\n↔ = \\leftrightarrow,\n⇒ = \\Rightarrow,\n⇐ = \\Leftarrow,\n⇔ = \\LeftrightarrowThis may seem cumbersome at first, but with some practice allows you to specify your models in a really elegant way: [x₁ x₂ x₃] ← ξ → η → [y₁ y₂ y₃].","category":"page"},{"location":"tutorials/specification/graph_interface/#Options","page":"Graph interface","title":"Options","text":"","category":"section"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"The graph syntax allows you to fix parameters to specific values, label them, and encode equality constraints by giving different parameters the same label. The following syntax example","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"graph = @StenoGraph begin\n\n    ξ₁ → fixed(1.0)*x1 + x2 + label(:a)*x3\n    ξ₂ → fixed(1.0)*x4 + x5 + label(:λ₁)*x6\n    ξ₃ → fixed(NaN)*x7 + x8 + label(:λ₁)*x9\n\n    ξ₃ ↔ fixed(1.0)*ξ₃\n    ...\n\nend","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"would ","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"fix the directed effects from ξ₁ to x1 and from ξ₂ to x2 to 1\nleave the directed effect from ξ₃ to x3 free but instead restrict the variance of ξ₃ to 1\ngive the effect from ξ₁ to x3 the label :a (which can be convenient later if you want to retrieve information from your model about that specific parameter)\nconstrain the effect from ξ₂ to x6 and ξ₃ to x9 to be equal as they are both labeled the same.","category":"page"},{"location":"tutorials/specification/graph_interface/#Using-variables-inside-the-graph-specification","page":"Graph interface","title":"Using variables inside the graph specification","text":"","category":"section"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"As you saw above and in the A first model example, the graph object needs to be converted to a parameter table:","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"partable = ParameterTable(\n    latent_vars = latent_vars, \n    observed_vars = observed_vars, \n    graph = graph)","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"The ParameterTable constructor also needs you to specify a vector of observed and latent variables, in the example above this would correspond to","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"observed_vars = [:x1 :x2 :x3 :x4 :x5 :x6 :x7 :x8 :x9]\nlatent_vars   = [:ξ₁ :ξ₂ :ξ₃]","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"The variable names (:x1) have to be symbols, the syntax :something creates an object of type Symbol. But you can also use vectors of symbols inside the graph specification, escaping them with _(...). For example, this graph specification","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"@StenoGraph begin\n    _(observed_vars) ↔ _(observed_vars)\n    _(latent_vars) ⇔ _(latent_vars)\nend","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"creates undirected effects coresponding to ","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"the variances of all observed variables and\nthe variances plus covariances of all latent variables","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"So if you want to work with a subset of variables, simply specify a vector of symbols somevars = [...], and inside the graph specification, refer to them as _(somevars).","category":"page"},{"location":"tutorials/specification/graph_interface/#Meanstructure","page":"Graph interface","title":"Meanstructure","text":"","category":"section"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"Mean parameters are specified as a directed effect from 1 to the respective variable. In our example above, to estimate a mean parameter for all observed variables, we may write","category":"page"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"@StenoGraph begin\n    Symbol(\"1\") → _(observed_vars)\nend","category":"page"},{"location":"tutorials/specification/graph_interface/#Further-Reading","page":"Graph interface","title":"Further Reading","text":"","category":"section"},{"location":"tutorials/specification/graph_interface/#What's-this-strange-looking-@-thing?","page":"Graph interface","title":"What's this strange looking @-thing?","text":"","category":"section"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"The syntax to specify graphs (@StenoGraph) may seem a bit strange if you are not familiar with the julia language. It is called a macro, but explaining this concept in detail is beyond this documentation (and not necessary to understand to specify models). However, if you want to know more about it, you may have a look at the respective part of the manual.","category":"page"},{"location":"tutorials/specification/graph_interface/#The-StenoGraphs-Package","page":"Graph interface","title":"The StenoGraphs Package","text":"","category":"section"},{"location":"tutorials/specification/graph_interface/","page":"Graph interface","title":"Graph interface","text":"Behind the scenes, we are using the StenoGraphs package to specify our graphs. It makes a domain specific language available that allows you to specify graphs with arbitrary information attached to its edges and nodes (for structural equation models, this may be the name or the value of a parameter). Is also allows you to specify your own types to \"attach\" to the graph, called a Modifier. So if you contemplate about writing your own modifier (e.g., to mark a variable as ordinal, an effect as quadratic, ...), please refer to the StenoGraphs documentation.","category":"page"},{"location":"tutorials/construction/build_by_parts/#Building-a-model-by-parts","page":"Building a model by parts","title":"Building a model by parts","text":"","category":"section"},{"location":"tutorials/multigroup/collection/#How-to-fit-sums-of-SEMS","page":"How to fit sums of SEMS","title":"How to fit sums of SEMS","text":"","category":"section"},{"location":"#StructuralEquationModes.jl:-a-fast-and-flexible-SEM-framework","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"StructuralEquationModes.jl: a fast and flexible SEM framework","text":"","category":"section"},{"location":"","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"StructuralEquationModes.jl: a fast and flexible SEM framework","text":"This is a package for Structural Equation Modeling. It is still in development. Models you can fit include","category":"page"},{"location":"","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"StructuralEquationModes.jl: a fast and flexible SEM framework","text":"Linear SEM that can be specified in RAM notation\nML, GLS and FIML estimation\nRidge Regularization\nMultigroup SEM\nSums of arbitrary loss functions (everything the optimizer can handle)","category":"page"},{"location":"","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"StructuralEquationModes.jl: a fast and flexible SEM framework","text":"We provide fast objective functions, gradients, and for some cases hessians as well as approximations thereof. As a user, you can easily define custom loss functions. For those, you can decide to provide analytical gradients or use finite difference approximation / automatic differentiation. You can choose to mix and match loss functions natively found in this package and those you provide. In such cases, you optimize over a sum of different objectives (e.g. ML + Ridge). This mix and match strategy also applies to gradients, where you may supply analytic gradients or opt for automatic differentiation or mix analytical and automatic differentiation.","category":"page"},{"location":"","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"StructuralEquationModes.jl: a fast and flexible SEM framework","text":"You may consider using this package if:","category":"page"},{"location":"","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"StructuralEquationModes.jl: a fast and flexible SEM framework","text":"you want to extend SEM (e.g. add a new objective function) and need an extendable framework\nyou want to extend SEM, and your implementation needs to be fast (because you want to do a simulation, for example)\nyou want to fit the same model(s) to many datasets (bootstrapping, simulation studies)\nyou are planning a study and would like to do power simulations","category":"page"},{"location":"","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"StructuralEquationModes.jl: a fast and flexible SEM framework","text":"For examples on how to use the package, see the Tutorials.","category":"page"},{"location":"#Installation","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"Installation","text":"","category":"section"},{"location":"","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"StructuralEquationModes.jl: a fast and flexible SEM framework","text":"To install the latest version from GitHub, use the following commands in your julia REPL:","category":"page"},{"location":"","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"StructuralEquationModes.jl: a fast and flexible SEM framework","text":"using Pkg\nPkd.add(\"https://github.com/StructuralEquationModels/StructuralEquationModels.jl\")","category":"page"},{"location":"#Citing-the-package","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"Citing the package","text":"","category":"section"},{"location":"","page":"StructuralEquationModes.jl: a fast and flexible SEM framework","title":"StructuralEquationModes.jl: a fast and flexible SEM framework","text":"To cite our package, see this page.","category":"page"}]
}
